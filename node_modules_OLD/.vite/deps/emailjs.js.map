{
  "version": 3,
  "sources": ["browser-external:fs", "browser-external:os", "browser-external:stream", "browser-external:util", "browser-external:crypto", "browser-external:events", "browser-external:net", "browser-external:tls", "../../emailjs/email.js"],
  "sourcesContent": ["module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"fs\" has been externalized for browser compatibility. Cannot access \"fs.${key}\" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"os\" has been externalized for browser compatibility. Cannot access \"os.${key}\" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"stream\" has been externalized for browser compatibility. Cannot access \"stream.${key}\" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"util\" has been externalized for browser compatibility. Cannot access \"util.${key}\" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"crypto\" has been externalized for browser compatibility. Cannot access \"crypto.${key}\" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"events\" has been externalized for browser compatibility. Cannot access \"events.${key}\" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"net\" has been externalized for browser compatibility. Cannot access \"net.${key}\" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"tls\" has been externalized for browser compatibility. Cannot access \"tls.${key}\" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "import { existsSync, open, read, closeSync, close } from 'fs';\nimport { hostname } from 'os';\nimport { Stream } from 'stream';\nimport { TextEncoder, TextDecoder } from 'util';\nimport { createHmac } from 'crypto';\nimport { EventEmitter } from 'events';\nimport { Socket } from 'net';\nimport { connect, TLSSocket, createSecureContext } from 'tls';\n\n/*\n * Operator tokens and which tokens are expected to end the sequence\n */\nconst OPERATORS = new Map([\n    ['\"', '\"'],\n    ['(', ')'],\n    ['<', '>'],\n    [',', ''],\n    // Groups are ended by semicolons\n    [':', ';'],\n    // Semicolons are not a legal delimiter per the RFC2822 grammar other\n    // than for terminating a group, but they are also not valid for any\n    // other use in this context.  Given that some mail clients have\n    // historically allowed the semicolon as a delimiter equivalent to the\n    // comma in their UI, it makes sense to treat them the same as a comma\n    // when used outside of a group.\n    [';', ''],\n]);\n/**\n * Tokenizes the original input string\n *\n * @param {string | string[] | undefined} address string(s) to tokenize\n * @return {AddressToken[]} An array of operator|text tokens\n */\nfunction tokenizeAddress(address = '') {\n    var _a, _b;\n    const tokens = [];\n    let token = undefined;\n    let operator = undefined;\n    for (const character of address.toString()) {\n        if (((_a = operator === null || operator === void 0 ? void 0 : operator.length) !== null && _a !== void 0 ? _a : 0) > 0 && character === operator) {\n            tokens.push({ type: 'operator', value: character });\n            token = undefined;\n            operator = undefined;\n        }\n        else if (((_b = operator === null || operator === void 0 ? void 0 : operator.length) !== null && _b !== void 0 ? _b : 0) === 0 && OPERATORS.has(character)) {\n            tokens.push({ type: 'operator', value: character });\n            token = undefined;\n            operator = OPERATORS.get(character);\n        }\n        else {\n            if (token == null) {\n                token = { type: 'text', value: character };\n                tokens.push(token);\n            }\n            else {\n                token.value += character;\n            }\n        }\n    }\n    return tokens\n        .map((x) => {\n        x.value = x.value.trim();\n        return x;\n    })\n        .filter((x) => x.value.length > 0);\n}\n/**\n * Converts tokens for a single address into an address object\n *\n * @param {AddressToken[]} tokens Tokens object\n * @return {AddressObject[]} addresses object array\n */\nfunction convertAddressTokens(tokens) {\n    const addressObjects = [];\n    const groups = [];\n    let addresses = [];\n    let comments = [];\n    let texts = [];\n    let state = 'text';\n    let isGroup = false;\n    function handleToken(token) {\n        if (token.type === 'operator') {\n            switch (token.value) {\n                case '<':\n                    state = 'address';\n                    break;\n                case '(':\n                    state = 'comment';\n                    break;\n                case ':':\n                    state = 'group';\n                    isGroup = true;\n                    break;\n                default:\n                    state = 'text';\n                    break;\n            }\n        }\n        else if (token.value.length > 0) {\n            switch (state) {\n                case 'address':\n                    addresses.push(token.value);\n                    break;\n                case 'comment':\n                    comments.push(token.value);\n                    break;\n                case 'group':\n                    groups.push(token.value);\n                    break;\n                default:\n                    texts.push(token.value);\n                    break;\n            }\n        }\n    }\n    // Filter out <addresses>, (comments) and regular text\n    for (const token of tokens) {\n        handleToken(token);\n    }\n    // If there is no text but a comment, replace the two\n    if (texts.length === 0 && comments.length > 0) {\n        texts = [...comments];\n        comments = [];\n    }\n    // http://tools.ietf.org/html/rfc2822#appendix-A.1.3\n    if (isGroup) {\n        addressObjects.push({\n            name: texts.length === 0 ? undefined : texts.join(' '),\n            group: groups.length > 0 ? addressparser(groups.join(',')) : [],\n        });\n    }\n    else {\n        // If no address was found, try to detect one from regular text\n        if (addresses.length === 0 && texts.length > 0) {\n            for (let i = texts.length - 1; i >= 0; i--) {\n                if (texts[i].match(/^[^@\\s]+@[^@\\s]+$/)) {\n                    addresses = texts.splice(i, 1);\n                    break;\n                }\n            }\n            // still no address\n            if (addresses.length === 0) {\n                for (let i = texts.length - 1; i >= 0; i--) {\n                    texts[i] = texts[i]\n                        .replace(/\\s*\\b[^@\\s]+@[^@\\s]+\\b\\s*/, (address) => {\n                        if (addresses.length === 0) {\n                            addresses = [address.trim()];\n                            return ' ';\n                        }\n                        else {\n                            return address;\n                        }\n                    })\n                        .trim();\n                    if (addresses.length > 0) {\n                        break;\n                    }\n                }\n            }\n        }\n        // If there's still is no text but a comment exixts, replace the two\n        if (texts.length === 0 && comments.length > 0) {\n            texts = [...comments];\n            comments = [];\n        }\n        // Keep only the first address occurence, push others to regular text\n        if (addresses.length > 1) {\n            texts = [...texts, ...addresses.splice(1)];\n        }\n        if (addresses.length === 0 && isGroup) {\n            return [];\n        }\n        else {\n            // Join values with spaces\n            let address = addresses.join(' ');\n            let name = texts.length === 0 ? address : texts.join(' ');\n            if (address === name) {\n                if (address.match(/@/)) {\n                    name = '';\n                }\n                else {\n                    address = '';\n                }\n            }\n            addressObjects.push({ address, name });\n        }\n    }\n    return addressObjects;\n}\n/**\n * Parses structured e-mail addresses from an address field\n *\n * Example:\n *\n *    \"Name <address@domain>\"\n *\n * will be converted to\n *\n *     [{name: \"Name\", address: \"address@domain\"}]\n *\n * @param {string | string[] | undefined} address Address field\n * @return {AddressObject[]} An array of address objects\n */\nfunction addressparser(address) {\n    const addresses = [];\n    let tokens = [];\n    for (const token of tokenizeAddress(address)) {\n        if (token.type === 'operator' &&\n            (token.value === ',' || token.value === ';')) {\n            if (tokens.length > 0) {\n                addresses.push(...convertAddressTokens(tokens));\n            }\n            tokens = [];\n        }\n        else {\n            tokens.push(token);\n        }\n    }\n    if (tokens.length > 0) {\n        addresses.push(...convertAddressTokens(tokens));\n    }\n    return addresses;\n}\n\n/**\n * @param {Date} [date] an optional date to convert to RFC2822 format\n * @param {boolean} [useUtc] whether to parse the date as UTC (default: false)\n * @returns {string} the converted date\n */\nfunction getRFC2822Date(date = new Date(), useUtc = false) {\n    if (useUtc) {\n        return getRFC2822DateUTC(date);\n    }\n    const dates = date\n        .toString()\n        .replace('GMT', '')\n        .replace(/\\s\\(.*\\)$/, '')\n        .split(' ');\n    dates[0] = dates[0] + ',';\n    const day = dates[1];\n    dates[1] = dates[2];\n    dates[2] = day;\n    return dates.join(' ');\n}\n/**\n * @param {Date} [date] an optional date to convert to RFC2822 format (UTC)\n * @returns {string} the converted date\n */\nfunction getRFC2822DateUTC(date = new Date()) {\n    const dates = date.toUTCString().split(' ');\n    dates.pop(); // remove timezone\n    dates.push('+0000');\n    return dates.join(' ');\n}\n/**\n * RFC 2822 regex\n * @see https://tools.ietf.org/html/rfc2822#section-3.3\n * @see https://github.com/moment/moment/blob/a831fc7e2694281ce31e4f090bbcf90a690f0277/src/lib/create/from-string.js#L101\n */\nconst rfc2822re = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\\d{4}))$/;\n/**\n * @param {string} [date] a string to check for conformance to the [rfc2822](https://tools.ietf.org/html/rfc2822#section-3.3) standard\n * @returns {boolean} the result of the conformance check\n */\nfunction isRFC2822Date(date) {\n    return rfc2822re.test(date);\n}\n\n// adapted from https://github.com/emailjs/emailjs-mime-codec/blob/6909c706b9f09bc0e5c3faf48f723cca53e5b352/src/mimecodec.js\nconst encoder = new TextEncoder();\n/**\n * @see https://tools.ietf.org/html/rfc2045#section-6.7\n */\nconst RANGES = [\n    [0x09],\n    [0x0a],\n    [0x0d],\n    [0x20, 0x3c],\n    [0x3e, 0x7e], // >?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}\n];\nconst LOOKUP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\nconst MAX_CHUNK_LENGTH = 16383; // must be multiple of 3\nconst MAX_MIME_WORD_LENGTH = 52;\nconst MAX_B64_MIME_WORD_BYTE_LENGTH = 39;\nfunction tripletToBase64(num) {\n    return (LOOKUP[(num >> 18) & 0x3f] +\n        LOOKUP[(num >> 12) & 0x3f] +\n        LOOKUP[(num >> 6) & 0x3f] +\n        LOOKUP[num & 0x3f]);\n}\nfunction encodeChunk(uint8, start, end) {\n    let output = '';\n    for (let i = start; i < end; i += 3) {\n        output += tripletToBase64((uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2]);\n    }\n    return output;\n}\nfunction encodeBase64(data) {\n    const len = data.length;\n    const extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n    let output = '';\n    // go through the array every three bytes, we'll deal with trailing stuff later\n    for (let i = 0, len2 = len - extraBytes; i < len2; i += MAX_CHUNK_LENGTH) {\n        output += encodeChunk(data, i, i + MAX_CHUNK_LENGTH > len2 ? len2 : i + MAX_CHUNK_LENGTH);\n    }\n    // pad the end with zeros, but make sure to not forget the extra bytes\n    if (extraBytes === 1) {\n        const tmp = data[len - 1];\n        output += LOOKUP[tmp >> 2];\n        output += LOOKUP[(tmp << 4) & 0x3f];\n        output += '==';\n    }\n    else if (extraBytes === 2) {\n        const tmp = (data[len - 2] << 8) + data[len - 1];\n        output += LOOKUP[tmp >> 10];\n        output += LOOKUP[(tmp >> 4) & 0x3f];\n        output += LOOKUP[(tmp << 2) & 0x3f];\n        output += '=';\n    }\n    return output;\n}\n/**\n * Splits a mime encoded string. Needed for dividing mime words into smaller chunks\n *\n * @param {string} str Mime encoded string to be split up\n * @param {number} maxlen Maximum length of characters for one part (minimum 12)\n * @return {string[]} lines\n */\nfunction splitMimeEncodedString(str, maxlen = 12) {\n    const minWordLength = 12; // require at least 12 symbols to fit possible 4 octet UTF-8 sequences\n    const maxWordLength = Math.max(maxlen, minWordLength);\n    const lines = [];\n    while (str.length) {\n        let curLine = str.substr(0, maxWordLength);\n        const match = curLine.match(/=[0-9A-F]?$/i); // skip incomplete escaped char\n        if (match) {\n            curLine = curLine.substr(0, match.index);\n        }\n        let done = false;\n        while (!done) {\n            let chr;\n            done = true;\n            const match = str.substr(curLine.length).match(/^=([0-9A-F]{2})/i); // check if not middle of a unicode char sequence\n            if (match) {\n                chr = parseInt(match[1], 16);\n                // invalid sequence, move one char back anc recheck\n                if (chr < 0xc2 && chr > 0x7f) {\n                    curLine = curLine.substr(0, curLine.length - 3);\n                    done = false;\n                }\n            }\n        }\n        if (curLine.length) {\n            lines.push(curLine);\n        }\n        str = str.substr(curLine.length);\n    }\n    return lines;\n}\n/**\n *\n * @param {number} nr number\n * @returns {boolean} if number is in range\n */\nfunction checkRanges(nr) {\n    return RANGES.reduce((val, range) => val ||\n        (range.length === 1 && nr === range[0]) ||\n        (range.length === 2 && nr >= range[0] && nr <= range[1]), false);\n}\n/**\n * Encodes all non printable and non ascii bytes to =XX form, where XX is the\n * byte value in hex. This function does not convert linebreaks etc. it\n * only escapes character sequences\n *\n * NOTE: Encoding support depends on util.TextDecoder, which is severely limited\n * prior to Node.js 13.\n *\n * @see https://nodejs.org/api/util.html#util_whatwg_supported_encodings\n * @see https://github.com/nodejs/node/issues/19214\n *\n * @param {string|Uint8Array} data Either a string or an Uint8Array\n * @param {string} encoding WHATWG supported encoding\n * @return {string} Mime encoded string\n */\nfunction mimeEncode(data = '', encoding = 'utf-8') {\n    const decoder = new TextDecoder(encoding);\n    const buffer = typeof data === 'string'\n        ? encoder.encode(data)\n        : encoder.encode(decoder.decode(data));\n    return buffer.reduce((aggregate, ord, index) => checkRanges(ord) &&\n        !((ord === 0x20 || ord === 0x09) &&\n            (index === buffer.length - 1 ||\n                buffer[index + 1] === 0x0a ||\n                buffer[index + 1] === 0x0d))\n        ? // if the char is in allowed range, then keep as is, unless it is a ws in the end of a line\n            aggregate + String.fromCharCode(ord)\n        : `${aggregate}=${ord < 0x10 ? '0' : ''}${ord\n            .toString(16)\n            .toUpperCase()}`, '');\n}\n/**\n * Encodes a string or an Uint8Array to an UTF-8 MIME Word\n *\n * NOTE: Encoding support depends on util.TextDecoder, which is severely limited\n * prior to Node.js 13.\n *\n * @see https://tools.ietf.org/html/rfc2047\n * @see https://nodejs.org/api/util.html#util_whatwg_supported_encodings\n * @see https://github.com/nodejs/node/issues/19214\n *\n * @param {string|Uint8Array} data String to be encoded\n * @param {'Q' | 'B'} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n * @param {string} encoding WHATWG supported encoding\n * @return {string} Single or several mime words joined together\n */\nfunction mimeWordEncode(data, mimeWordEncoding = 'Q', encoding = 'utf-8') {\n    let parts = [];\n    const decoder = new TextDecoder(encoding);\n    const str = typeof data === 'string' ? data : decoder.decode(data);\n    if (mimeWordEncoding === 'Q') {\n        const encodedStr = mimeEncode(str, encoding).replace(/[^a-z0-9!*+\\-/=]/gi, (chr) => chr === ' '\n            ? '_'\n            : '=' +\n                (chr.charCodeAt(0) < 0x10 ? '0' : '') +\n                chr.charCodeAt(0).toString(16).toUpperCase());\n        parts =\n            encodedStr.length < MAX_MIME_WORD_LENGTH\n                ? [encodedStr]\n                : splitMimeEncodedString(encodedStr, MAX_MIME_WORD_LENGTH);\n    }\n    else {\n        // Fits as much as possible into every line without breaking utf-8 multibyte characters' octets up across lines\n        let j = 0;\n        let i = 0;\n        while (i < str.length) {\n            if (encoder.encode(str.substring(j, i)).length >\n                MAX_B64_MIME_WORD_BYTE_LENGTH) {\n                // we went one character too far, substring at the char before\n                parts.push(str.substring(j, i - 1));\n                j = i - 1;\n            }\n            else {\n                i++;\n            }\n        }\n        // add the remainder of the string\n        str.substring(j) && parts.push(str.substring(j));\n        parts = parts.map((x) => encoder.encode(x)).map((x) => encodeBase64(x));\n    }\n    return parts\n        .map((p) => `=?UTF-8?${mimeWordEncoding}?${p}?= `)\n        .join('')\n        .trim();\n}\n\nconst CRLF$1 = '\\r\\n';\n/**\n * MIME standard wants 76 char chunks when sending out.\n */\nconst MIMECHUNK = 76;\n/**\n * meets both base64 and mime divisibility\n */\nconst MIME64CHUNK = (MIMECHUNK * 6);\n/**\n * size of the message stream buffer\n */\nconst BUFFERSIZE = (MIMECHUNK * 24 * 7);\nlet counter = 0;\nfunction generateBoundary() {\n    let text = '';\n    const possible = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'()+_,-./:=?\";\n    for (let i = 0; i < 69; i++) {\n        text += possible.charAt(Math.floor(Math.random() * possible.length));\n    }\n    return text;\n}\nfunction convertPersonToAddress(person) {\n    return addressparser(person)\n        .map(({ name, address }) => {\n        return name\n            ? `${mimeWordEncode(name).replace(/,/g, '=2C')} <${address}>`\n            : address;\n    })\n        .join(', ');\n}\nfunction convertDashDelimitedTextToSnakeCase(text) {\n    return text\n        .toLowerCase()\n        .replace(/^(.)|-(.)/g, (match) => match.toUpperCase());\n}\nclass Message {\n    /**\n     * Construct an rfc2822-compliant message object.\n     *\n     * Special notes:\n     * - The `from` field is required.\n     * - At least one `to`, `cc`, or `bcc` header is also required.\n     * - You can also add whatever other headers you want.\n     *\n     * @see https://tools.ietf.org/html/rfc2822\n     * @param {Partial<MessageHeaders>} headers Message headers\n     */\n    constructor(headers) {\n        this.attachments = [];\n        this.header = {\n            'message-id': `<${new Date().getTime()}.${counter++}.${process.pid}@${hostname()}>`,\n            date: getRFC2822Date(),\n        };\n        this.content = 'text/plain; charset=utf-8';\n        this.alternative = null;\n        for (const header in headers) {\n            // allow user to override default content-type to override charset or send a single non-text message\n            if (/^content-type$/i.test(header)) {\n                this.content = headers[header];\n            }\n            else if (header === 'text') {\n                this.text = headers[header];\n            }\n            else if (header === 'attachment' &&\n                typeof headers[header] === 'object') {\n                const attachment = headers[header];\n                if (Array.isArray(attachment)) {\n                    for (let i = 0; i < attachment.length; i++) {\n                        this.attach(attachment[i]);\n                    }\n                }\n                else if (attachment != null) {\n                    this.attach(attachment);\n                }\n            }\n            else if (header === 'subject') {\n                this.header.subject = mimeWordEncode(headers.subject);\n            }\n            else if (/^(cc|bcc|to|from)/i.test(header)) {\n                this.header[header.toLowerCase()] = convertPersonToAddress(headers[header]);\n            }\n            else {\n                // allow any headers the user wants to set??\n                this.header[header.toLowerCase()] = headers[header];\n            }\n        }\n    }\n    /**\n     * Attach a file to the message.\n     *\n     * Can be called multiple times, each adding a new attachment.\n     *\n     * @public\n     * @param {MessageAttachment} options attachment options\n     * @returns {Message} the current instance for chaining\n     */\n    attach(options) {\n        // sender can specify an attachment as an alternative\n        if (options.alternative) {\n            this.alternative = options;\n            this.alternative.charset = options.charset || 'utf-8';\n            this.alternative.type = options.type || 'text/html';\n            this.alternative.inline = true;\n        }\n        else {\n            this.attachments.push(options);\n        }\n        return this;\n    }\n    /**\n     * @public\n     * @returns {{ isValid: boolean, validationError: (string | undefined) }} an object specifying whether this message is validly formatted, and the first validation error if it is not.\n     */\n    checkValidity() {\n        if (typeof this.header.from !== 'string' &&\n            Array.isArray(this.header.from) === false) {\n            return {\n                isValid: false,\n                validationError: 'Message must have a `from` header',\n            };\n        }\n        if (typeof this.header.to !== 'string' &&\n            Array.isArray(this.header.to) === false &&\n            typeof this.header.cc !== 'string' &&\n            Array.isArray(this.header.cc) === false &&\n            typeof this.header.bcc !== 'string' &&\n            Array.isArray(this.header.bcc) === false) {\n            return {\n                isValid: false,\n                validationError: 'Message must have at least one `to`, `cc`, or `bcc` header',\n            };\n        }\n        if (this.attachments.length > 0) {\n            const failed = [];\n            this.attachments.forEach((attachment) => {\n                if (attachment.path) {\n                    if (existsSync(attachment.path) === false) {\n                        failed.push(`${attachment.path} does not exist`);\n                    }\n                }\n                else if (attachment.stream) {\n                    if (!attachment.stream.readable) {\n                        failed.push('attachment stream is not readable');\n                    }\n                }\n                else if (!attachment.data) {\n                    failed.push('attachment has no data associated with it');\n                }\n            });\n            return {\n                isValid: failed.length === 0,\n                validationError: failed.join(', '),\n            };\n        }\n        return { isValid: true, validationError: undefined };\n    }\n    /**\n     * @public\n     * @deprecated does not conform to the `errback` style followed by the rest of the library, and will be removed in the next major version. use `checkValidity` instead.\n     * @param {function(isValid: boolean, invalidReason: (string | undefined)): void} callback .\n     * @returns {void}\n     */\n    valid(callback) {\n        const { isValid, validationError } = this.checkValidity();\n        callback(isValid, validationError);\n    }\n    /**\n     * @public\n     * @returns {MessageStream} a stream of the current message\n     */\n    stream() {\n        return new MessageStream(this);\n    }\n    /**\n     * @public\n     * @param {function(Error, string): void} callback the function to call with the error and buffer\n     * @returns {void}\n     */\n    read(callback) {\n        let buffer = '';\n        const str = this.stream();\n        str.on('data', (data) => (buffer += data));\n        str.on('end', (err) => callback(err, buffer));\n        str.on('error', (err) => callback(err, buffer));\n    }\n    readAsync() {\n        return new Promise((resolve, reject) => {\n            this.read((err, buffer) => {\n                if (err != null) {\n                    reject(err);\n                }\n                else {\n                    resolve(buffer);\n                }\n            });\n        });\n    }\n}\nclass MessageStream extends Stream {\n    /**\n     * @param {Message} message the message to stream\n     */\n    constructor(message) {\n        super();\n        this.message = message;\n        this.readable = true;\n        this.paused = false;\n        this.buffer = Buffer.alloc(MIMECHUNK * 24 * 7);\n        this.bufferIndex = 0;\n        /**\n         * @param {string} [data] the data to output\n         * @param {Function} [callback] the function\n         * @param {any[]} [args] array of arguments to pass to the callback\n         * @returns {void}\n         */\n        const output = (data) => {\n            // can we buffer the data?\n            if (this.buffer != null) {\n                const bytes = Buffer.byteLength(data);\n                if (bytes + this.bufferIndex < this.buffer.length) {\n                    this.buffer.write(data, this.bufferIndex);\n                    this.bufferIndex += bytes;\n                }\n                // we can't buffer the data, so ship it out!\n                else if (bytes > this.buffer.length) {\n                    if (this.bufferIndex) {\n                        this.emit('data', this.buffer.toString('utf-8', 0, this.bufferIndex));\n                        this.bufferIndex = 0;\n                    }\n                    const loops = Math.ceil(data.length / this.buffer.length);\n                    let loop = 0;\n                    while (loop < loops) {\n                        this.emit('data', data.substring(this.buffer.length * loop, this.buffer.length * (loop + 1)));\n                        loop++;\n                    }\n                } // we need to clean out the buffer, it is getting full\n                else {\n                    if (!this.paused) {\n                        this.emit('data', this.buffer.toString('utf-8', 0, this.bufferIndex));\n                        this.buffer.write(data, 0);\n                        this.bufferIndex = bytes;\n                    }\n                    else {\n                        // we can't empty out the buffer, so let's wait till we resume before adding to it\n                        this.once('resume', () => output(data));\n                    }\n                }\n            }\n        };\n        /**\n         * @param {MessageAttachment} [attachment] the attachment whose headers you would like to output\n         * @returns {void}\n         */\n        const outputAttachmentHeaders = (attachment) => {\n            let data = [];\n            const headers = {\n                'content-type': attachment.type +\n                    (attachment.charset ? `; charset=${attachment.charset}` : '') +\n                    (attachment.method ? `; method=${attachment.method}` : ''),\n                'content-transfer-encoding': 'base64',\n                'content-disposition': attachment.inline\n                    ? 'inline'\n                    : `attachment; filename=\"${mimeWordEncode(attachment.name)}\"`,\n            };\n            // allow sender to override default headers\n            if (attachment.headers != null) {\n                for (const header in attachment.headers) {\n                    headers[header.toLowerCase()] = attachment.headers[header];\n                }\n            }\n            for (const header in headers) {\n                data = data.concat([\n                    convertDashDelimitedTextToSnakeCase(header),\n                    ': ',\n                    headers[header],\n                    CRLF$1,\n                ]);\n            }\n            output(data.concat([CRLF$1]).join(''));\n        };\n        /**\n         * @param {string} data the data to output as base64\n         * @param {function(): void} [callback] the function to call after output is finished\n         * @returns {void}\n         */\n        const outputBase64 = (data, callback) => {\n            const loops = Math.ceil(data.length / MIMECHUNK);\n            let loop = 0;\n            while (loop < loops) {\n                output(data.substring(MIMECHUNK * loop, MIMECHUNK * (loop + 1)) + CRLF$1);\n                loop++;\n            }\n            if (callback) {\n                callback();\n            }\n        };\n        const outputFile = (attachment, next) => {\n            var _a;\n            const chunk = MIME64CHUNK * 16;\n            const buffer = Buffer.alloc(chunk);\n            const inputEncoding = ((_a = attachment === null || attachment === void 0 ? void 0 : attachment.headers) === null || _a === void 0 ? void 0 : _a['content-transfer-encoding']) || 'base64';\n            const encoding = inputEncoding === '7bit'\n                ? 'ascii'\n                : inputEncoding === '8bit'\n                    ? 'binary'\n                    : inputEncoding;\n            /**\n             * @param {Error} err the error to emit\n             * @param {number} fd the file descriptor\n             * @returns {void}\n             */\n            const opened = (err, fd) => {\n                if (err) {\n                    this.emit('error', err);\n                    return;\n                }\n                const readBytes = (err, bytes) => {\n                    if (err || this.readable === false) {\n                        this.emit('error', err || new Error('message stream was interrupted somehow!'));\n                        return;\n                    }\n                    // guaranteed to be encoded without padding unless it is our last read\n                    outputBase64(buffer.toString(encoding, 0, bytes), () => {\n                        if (bytes == chunk) {\n                            // we read a full chunk, there might be more\n                            read(fd, buffer, 0, chunk, null, readBytes);\n                        } // that was the last chunk, we are done reading the file\n                        else {\n                            this.removeListener('error', closeSync);\n                            close(fd, next);\n                        }\n                    });\n                };\n                read(fd, buffer, 0, chunk, null, readBytes);\n                this.once('error', closeSync);\n            };\n            open(attachment.path, 'r', opened);\n        };\n        /**\n         * @param {MessageAttachment} attachment the metadata to use as headers\n         * @param {function(): void} callback the function to call after output is finished\n         * @returns {void}\n         */\n        const outputStream = (attachment, callback) => {\n            const { stream } = attachment;\n            if (stream === null || stream === void 0 ? void 0 : stream.readable) {\n                let previous = Buffer.alloc(0);\n                stream.resume();\n                stream.on('end', () => {\n                    outputBase64(previous.toString('base64'), callback);\n                    this.removeListener('pause', stream.pause);\n                    this.removeListener('resume', stream.resume);\n                    this.removeListener('error', stream.resume);\n                });\n                stream.on('data', (buff) => {\n                    // do we have bytes from a previous stream data event?\n                    let buffer = Buffer.isBuffer(buff) ? buff : Buffer.from(buff);\n                    if (previous.byteLength > 0) {\n                        buffer = Buffer.concat([previous, buffer]);\n                    }\n                    const padded = buffer.length % MIME64CHUNK;\n                    previous = Buffer.alloc(padded);\n                    // encode as much of the buffer to base64 without empty bytes\n                    if (padded > 0) {\n                        // copy dangling bytes into previous buffer\n                        buffer.copy(previous, 0, buffer.length - padded);\n                    }\n                    outputBase64(buffer.toString('base64', 0, buffer.length - padded));\n                });\n                this.on('pause', stream.pause);\n                this.on('resume', stream.resume);\n                this.on('error', stream.resume);\n            }\n            else {\n                this.emit('error', { message: 'stream not readable' });\n            }\n        };\n        const outputAttachment = (attachment, callback) => {\n            const build = attachment.path\n                ? outputFile\n                : attachment.stream\n                    ? outputStream\n                    : outputData;\n            outputAttachmentHeaders(attachment);\n            build(attachment, callback);\n        };\n        /**\n         * @param {string} boundary the boundary text between outputs\n         * @param {MessageAttachment[]} list the list of potential messages to output\n         * @param {number} index the index of the list item to output\n         * @param {function(): void} callback the function to call if index is greater than upper bound\n         * @returns {void}\n         */\n        const outputMessage = (boundary, list, index, callback) => {\n            if (index < list.length) {\n                output(`--${boundary}${CRLF$1}`);\n                if (list[index].related) {\n                    outputRelated(list[index], () => outputMessage(boundary, list, index + 1, callback));\n                }\n                else {\n                    outputAttachment(list[index], () => outputMessage(boundary, list, index + 1, callback));\n                }\n            }\n            else {\n                output(`${CRLF$1}--${boundary}--${CRLF$1}${CRLF$1}`);\n                callback();\n            }\n        };\n        const outputMixed = () => {\n            const boundary = generateBoundary();\n            output(`Content-Type: multipart/mixed; boundary=\"${boundary}\"${CRLF$1}${CRLF$1}--${boundary}${CRLF$1}`);\n            if (this.message.alternative == null) {\n                outputText(this.message);\n                outputMessage(boundary, this.message.attachments, 0, close$1);\n            }\n            else {\n                outputAlternative(\n                // typescript bug; should narrow to { alternative: MessageAttachment }\n                this.message, () => outputMessage(boundary, this.message.attachments, 0, close$1));\n            }\n        };\n        /**\n         * @param {MessageAttachment} attachment the metadata to use as headers\n         * @param {function(): void} callback the function to call after output is finished\n         * @returns {void}\n         */\n        const outputData = (attachment, callback) => {\n            var _a, _b;\n            outputBase64(attachment.encoded\n                ? (_a = attachment.data) !== null && _a !== void 0 ? _a : ''\n                : Buffer.from((_b = attachment.data) !== null && _b !== void 0 ? _b : '').toString('base64'), callback);\n        };\n        /**\n         * @param {Message} message the message to output\n         * @returns {void}\n         */\n        const outputText = (message) => {\n            let data = [];\n            data = data.concat([\n                'Content-Type:',\n                message.content,\n                CRLF$1,\n                'Content-Transfer-Encoding: 7bit',\n                CRLF$1,\n            ]);\n            data = data.concat(['Content-Disposition: inline', CRLF$1, CRLF$1]);\n            data = data.concat([message.text || '', CRLF$1, CRLF$1]);\n            output(data.join(''));\n        };\n        /**\n         * @param {MessageAttachment} message the message to output\n         * @param {function(): void} callback the function to call after output is finished\n         * @returns {void}\n         */\n        const outputRelated = (message, callback) => {\n            const boundary = generateBoundary();\n            output(`Content-Type: multipart/related; boundary=\"${boundary}\"${CRLF$1}${CRLF$1}--${boundary}${CRLF$1}`);\n            outputAttachment(message, () => {\n                var _a;\n                outputMessage(boundary, (_a = message.related) !== null && _a !== void 0 ? _a : [], 0, () => {\n                    output(`${CRLF$1}--${boundary}--${CRLF$1}${CRLF$1}`);\n                    callback();\n                });\n            });\n        };\n        /**\n         * @param {Message} message the message to output\n         * @param {function(): void} callback the function to call after output is finished\n         * @returns {void}\n         */\n        const outputAlternative = (message, callback) => {\n            const boundary = generateBoundary();\n            output(`Content-Type: multipart/alternative; boundary=\"${boundary}\"${CRLF$1}${CRLF$1}--${boundary}${CRLF$1}`);\n            outputText(message);\n            output(`--${boundary}${CRLF$1}`);\n            /**\n             * @returns {void}\n             */\n            const finish = () => {\n                output([CRLF$1, '--', boundary, '--', CRLF$1, CRLF$1].join(''));\n                callback();\n            };\n            if (message.alternative.related) {\n                outputRelated(message.alternative, finish);\n            }\n            else {\n                outputAttachment(message.alternative, finish);\n            }\n        };\n        const close$1 = (err) => {\n            var _a, _b;\n            if (err) {\n                this.emit('error', err);\n            }\n            else {\n                this.emit('data', (_b = (_a = this.buffer) === null || _a === void 0 ? void 0 : _a.toString('utf-8', 0, this.bufferIndex)) !== null && _b !== void 0 ? _b : '');\n                this.emit('end');\n            }\n            this.buffer = null;\n            this.bufferIndex = 0;\n            this.readable = false;\n            this.removeAllListeners('resume');\n            this.removeAllListeners('pause');\n            this.removeAllListeners('error');\n            this.removeAllListeners('data');\n            this.removeAllListeners('end');\n        };\n        /**\n         * @returns {void}\n         */\n        const outputHeaderData = () => {\n            if (this.message.attachments.length || this.message.alternative) {\n                output(`MIME-Version: 1.0${CRLF$1}`);\n                outputMixed();\n            } // you only have a text message!\n            else {\n                outputText(this.message);\n                close$1();\n            }\n        };\n        /**\n         * @returns {void}\n         */\n        const outputHeader = () => {\n            let data = [];\n            for (const header in this.message.header) {\n                // do not output BCC in the headers (regex) nor custom Object.prototype functions...\n                if (!/bcc/i.test(header) &&\n                    Object.prototype.hasOwnProperty.call(this.message.header, header)) {\n                    data = data.concat([\n                        convertDashDelimitedTextToSnakeCase(header),\n                        ': ',\n                        this.message.header[header],\n                        CRLF$1,\n                    ]);\n                }\n            }\n            output(data.join(''));\n            outputHeaderData();\n        };\n        this.once('destroy', close$1);\n        process.nextTick(outputHeader);\n    }\n    /**\n     * @public\n     * pause the stream\n     * @returns {void}\n     */\n    pause() {\n        this.paused = true;\n        this.emit('pause');\n    }\n    /**\n     * @public\n     * resume the stream\n     * @returns {void}\n     */\n    resume() {\n        this.paused = false;\n        this.emit('resume');\n    }\n    /**\n     * @public\n     * destroy the stream\n     * @returns {void}\n     */\n    destroy() {\n        this.emit('destroy', this.bufferIndex > 0 ? { message: 'message stream destroyed' } : null);\n    }\n    /**\n     * @public\n     * destroy the stream at first opportunity\n     * @returns {void}\n     */\n    destroySoon() {\n        this.emit('destroy');\n    }\n}\n\n/**\n * @readonly\n * @enum\n */\nconst SMTPErrorStates = {\n    COULDNOTCONNECT: 1,\n    BADRESPONSE: 2,\n    AUTHFAILED: 3,\n    TIMEDOUT: 4,\n    ERROR: 5,\n    NOCONNECTION: 6,\n    AUTHNOTSUPPORTED: 7,\n    CONNECTIONCLOSED: 8,\n    CONNECTIONENDED: 9,\n    CONNECTIONAUTH: 10,\n};\nclass SMTPError extends Error {\n    /**\n     * @protected\n     * @param {string} message error message\n     */\n    constructor(message) {\n        super(message);\n        this.code = null;\n        this.smtp = null;\n        this.previous = null;\n    }\n    /**\n     *\n     * @param {string} message error message\n     * @param {number} code smtp error state\n     * @param {Error | null} error previous error\n     * @param {unknown} smtp arbitrary data\n     * @returns {SMTPError} error\n     */\n    static create(message, code, error, smtp) {\n        const msg = (error === null || error === void 0 ? void 0 : error.message) ? `${message} (${error.message})` : message;\n        const err = new SMTPError(msg);\n        err.code = code;\n        err.smtp = smtp;\n        if (error) {\n            err.previous = error;\n        }\n        return err;\n    }\n}\n\nclass SMTPResponseMonitor {\n    constructor(stream, timeout, onerror) {\n        let buffer = '';\n        const notify = () => {\n            var _a, _b;\n            if (buffer.length) {\n                // parse buffer for response codes\n                const line = buffer.replace('\\r', '');\n                if (!((_b = (_a = line\n                    .trim()\n                    .split(/\\n/)\n                    .pop()) === null || _a === void 0 ? void 0 : _a.match(/^(\\d{3})\\s/)) !== null && _b !== void 0 ? _b : false)) {\n                    return;\n                }\n                const match = line ? line.match(/(\\d+)\\s?(.*)/) : null;\n                const data = match !== null\n                    ? { code: match[1], message: match[2], data: line }\n                    : { code: -1, data: line };\n                stream.emit('response', null, data);\n                buffer = '';\n            }\n        };\n        const error = (err) => {\n            stream.emit('response', SMTPError.create('connection encountered an error', SMTPErrorStates.ERROR, err));\n        };\n        const timedout = (err) => {\n            stream.end();\n            stream.emit('response', SMTPError.create('timedout while connecting to smtp server', SMTPErrorStates.TIMEDOUT, err));\n        };\n        const watch = (data) => {\n            if (data !== null) {\n                buffer += data.toString();\n                notify();\n            }\n        };\n        const close = (err) => {\n            stream.emit('response', SMTPError.create('connection has closed', SMTPErrorStates.CONNECTIONCLOSED, err));\n        };\n        const end = (err) => {\n            stream.emit('response', SMTPError.create('connection has ended', SMTPErrorStates.CONNECTIONENDED, err));\n        };\n        this.stop = (err) => {\n            stream.removeAllListeners('response');\n            stream.removeListener('data', watch);\n            stream.removeListener('end', end);\n            stream.removeListener('close', close);\n            stream.removeListener('error', error);\n            if (err != null && typeof onerror === 'function') {\n                onerror(err);\n            }\n        };\n        stream.on('data', watch);\n        stream.on('end', end);\n        stream.on('close', close);\n        stream.on('error', error);\n        stream.setTimeout(timeout, timedout);\n    }\n}\n\n/**\n * @readonly\n * @enum\n */\nconst AUTH_METHODS = {\n    PLAIN: 'PLAIN',\n    'CRAM-MD5': 'CRAM-MD5',\n    LOGIN: 'LOGIN',\n    XOAUTH2: 'XOAUTH2',\n};\n/**\n * @readonly\n * @enum\n */\nconst SMTPState = {\n    NOTCONNECTED: 0,\n    CONNECTING: 1,\n    CONNECTED: 2,\n};\nconst DEFAULT_TIMEOUT = 5000;\nconst SMTP_PORT = 25;\nconst SMTP_SSL_PORT = 465;\nconst SMTP_TLS_PORT = 587;\nconst CRLF = '\\r\\n';\nconst GREYLIST_DELAY = 300;\nlet DEBUG = 0;\n/**\n * @param {...any[]} args the message(s) to log\n * @returns {void}\n */\nconst log = (...args) => {\n    if (DEBUG === 1) {\n        args.forEach((d) => console.log(typeof d === 'object'\n            ? d instanceof Error\n                ? d.message\n                : JSON.stringify(d)\n            : d));\n    }\n};\n/**\n * @param {function(...any[]): void} callback the function to call\n * @param {...any[]} args the arguments to apply to the function\n * @returns {void}\n */\nconst caller = (callback, ...args) => {\n    if (typeof callback === 'function') {\n        callback(...args);\n    }\n};\nclass SMTPConnection extends EventEmitter {\n    /**\n     * SMTP class written using python's (2.7) smtplib.py as a base.\n     *\n     * To target a Message Transfer Agent (MTA), omit all options.\n     *\n     * NOTE: `host` is trimmed before being used to establish a connection; however, the original untrimmed value will still be visible in configuration.\n     */\n    constructor({ timeout, host, user, password, domain, port, ssl, tls, logger, authentication, } = {}) {\n        var _a;\n        super();\n        this.timeout = DEFAULT_TIMEOUT;\n        this.log = log;\n        this.authentication = [\n            AUTH_METHODS['CRAM-MD5'],\n            AUTH_METHODS.LOGIN,\n            AUTH_METHODS.PLAIN,\n            AUTH_METHODS.XOAUTH2,\n        ];\n        this._state = SMTPState.NOTCONNECTED;\n        this._secure = false;\n        this.loggedin = false;\n        this.sock = null;\n        this.features = null;\n        this.monitor = null;\n        this.domain = hostname();\n        this.host = 'localhost';\n        this.ssl = false;\n        this.tls = false;\n        this.greylistResponseTracker = new WeakSet();\n        if (Array.isArray(authentication)) {\n            this.authentication = authentication;\n        }\n        if (typeof timeout === 'number') {\n            this.timeout = timeout;\n        }\n        if (typeof domain === 'string') {\n            this.domain = domain;\n        }\n        if (typeof host === 'string') {\n            this.host = host;\n        }\n        if (ssl != null &&\n            (typeof ssl === 'boolean' ||\n                (typeof ssl === 'object' && Array.isArray(ssl) === false))) {\n            this.ssl = ssl;\n        }\n        if (tls != null &&\n            (typeof tls === 'boolean' ||\n                (typeof tls === 'object' && Array.isArray(tls) === false))) {\n            this.tls = tls;\n        }\n        this.port = port || (ssl ? SMTP_SSL_PORT : tls ? SMTP_TLS_PORT : SMTP_PORT);\n        this.loggedin = user && password ? false : true;\n        if (!user && ((_a = password === null || password === void 0 ? void 0 : password.length) !== null && _a !== void 0 ? _a : 0) > 0) {\n            throw new Error('`password` cannot be set without `user`');\n        }\n        // keep these strings hidden when quicky debugging/logging\n        this.user = () => user;\n        this.password = () => password;\n        if (typeof logger === 'function') {\n            this.log = logger;\n        }\n    }\n    /**\n     * @public\n     * @param {0 | 1} level -\n     * @returns {void}\n     */\n    debug(level) {\n        DEBUG = level;\n    }\n    /**\n     * @public\n     * @returns {SMTPState} the current state\n     */\n    state() {\n        return this._state;\n    }\n    /**\n     * @public\n     * @returns {boolean} whether or not the instance is authorized\n     */\n    authorized() {\n        return this.loggedin;\n    }\n    /**\n     * Establish an SMTP connection.\n     *\n     * NOTE: `host` is trimmed before being used to establish a connection; however, the original untrimmed value will still be visible in configuration.\n     *\n     * @public\n     * @param {function(...any[]): void} callback function to call after response\n     * @param {number} [port] the port to use for the connection\n     * @param {string} [host] the hostname to use for the connection\n     * @param {ConnectOptions} [options={}] the options\n     * @returns {void}\n     */\n    connect(callback, port = this.port, host = this.host, options = {}) {\n        this.port = port;\n        this.host = host;\n        this.ssl = options.ssl || this.ssl;\n        if (this._state !== SMTPState.NOTCONNECTED) {\n            this.quit(() => this.connect(callback, port, host, options));\n        }\n        /**\n         * @returns {void}\n         */\n        const connected = () => {\n            this.log(`connected: ${this.host}:${this.port}`);\n            if (this.ssl && !this.tls) {\n                // if key/ca/cert was passed in, check if connection is authorized\n                if (typeof this.ssl !== 'boolean' &&\n                    this.sock instanceof TLSSocket &&\n                    !this.sock.authorized) {\n                    this.close(true);\n                    caller(callback, SMTPError.create('could not establish an ssl connection', SMTPErrorStates.CONNECTIONAUTH));\n                }\n                else {\n                    this._secure = true;\n                }\n            }\n        };\n        /**\n         * @param {Error} err err\n         * @returns {void}\n         */\n        const connectedErrBack = (err) => {\n            if (!err) {\n                connected();\n            }\n            else {\n                this.close(true);\n                this.log(err);\n                caller(callback, SMTPError.create('could not connect', SMTPErrorStates.COULDNOTCONNECT, err));\n            }\n        };\n        const response = (err, msg) => {\n            if (err) {\n                if (this._state === SMTPState.NOTCONNECTED && !this.sock) {\n                    return;\n                }\n                this.close(true);\n                caller(callback, err);\n            }\n            else if (msg.code == '220') {\n                this.log(msg.data);\n                // might happen first, so no need to wait on connected()\n                this._state = SMTPState.CONNECTED;\n                caller(callback, null, msg.data);\n            }\n            else {\n                this.log(`response (data): ${msg.data}`);\n                this.quit(() => {\n                    caller(callback, SMTPError.create('bad response on connection', SMTPErrorStates.BADRESPONSE, err, msg.data));\n                });\n            }\n        };\n        this._state = SMTPState.CONNECTING;\n        this.log(`connecting: ${this.host}:${this.port}`);\n        if (this.ssl) {\n            this.sock = connect(this.port, this.host.trim(), typeof this.ssl === 'object' ? this.ssl : {}, connected);\n        }\n        else {\n            this.sock = new Socket();\n            this.sock.connect(this.port, this.host.trim(), connectedErrBack);\n        }\n        this.monitor = new SMTPResponseMonitor(this.sock, this.timeout, () => this.close(true));\n        this.sock.once('response', response);\n        this.sock.once('error', response); // the socket could reset or throw, so let's handle it and let the user know\n    }\n    /**\n     * @public\n     * @param {string} str the string to send\n     * @param {function(...any[]): void} callback function to call after response\n     * @returns {void}\n     */\n    send(str, callback) {\n        if (this.sock != null && this._state === SMTPState.CONNECTED) {\n            this.log(str);\n            this.sock.once('response', (err, msg) => {\n                if (err) {\n                    caller(callback, err);\n                }\n                else {\n                    this.log(msg.data);\n                    caller(callback, null, msg);\n                }\n            });\n            if (this.sock.writable) {\n                this.sock.write(str);\n            }\n        }\n        else {\n            this.close(true);\n            caller(callback, SMTPError.create('no connection has been established', SMTPErrorStates.NOCONNECTION));\n        }\n    }\n    /**\n     * @public\n     * @param {string} cmd command to issue\n     * @param {function(...any[]): void} callback function to call after response\n     * @param {(number[] | number)} [codes=[250]] array codes\n     * @returns {void}\n     */\n    command(cmd, callback, codes = [250]) {\n        const codesArray = Array.isArray(codes)\n            ? codes\n            : typeof codes === 'number'\n                ? [codes]\n                : [250];\n        const response = (err, msg) => {\n            if (err) {\n                caller(callback, err);\n            }\n            else {\n                const code = Number(msg.code);\n                if (codesArray.indexOf(code) !== -1) {\n                    caller(callback, err, msg.data, msg.message);\n                }\n                else if ((code === 450 || code === 451) &&\n                    msg.message.toLowerCase().includes('greylist') &&\n                    this.greylistResponseTracker.has(response) === false) {\n                    this.greylistResponseTracker.add(response);\n                    setTimeout(() => {\n                        this.send(cmd + CRLF, response);\n                    }, GREYLIST_DELAY);\n                }\n                else {\n                    const suffix = msg.message ? `: ${msg.message}` : '';\n                    const errorMessage = `bad response on command '${cmd.split(' ')[0]}'${suffix}`;\n                    caller(callback, SMTPError.create(errorMessage, SMTPErrorStates.BADRESPONSE, null, msg.data));\n                }\n            }\n        };\n        this.greylistResponseTracker.delete(response);\n        this.send(cmd + CRLF, response);\n    }\n    /**\n     * @public\n     * @description SMTP 'helo' command.\n     *\n     * Hostname to send for self command defaults to the FQDN of the local\n     * host.\n     *\n     * As this command was deprecated by rfc2821, it should only be used for compatibility with non-compliant servers.\n     * @see https://tools.ietf.org/html/rfc2821#appendix-F.3\n     *\n     * @param {function(...any[]): void} callback function to call after response\n     * @param {string} domain the domain to associate with the 'helo' request\n     * @returns {void}\n     */\n    helo(callback, domain) {\n        this.command(`helo ${domain || this.domain}`, (err, data) => {\n            if (err) {\n                caller(callback, err);\n            }\n            else {\n                this.parse_smtp_features(data);\n                caller(callback, err, data);\n            }\n        });\n    }\n    /**\n     * @public\n     * @param {function(...any[]): void} callback function to call after response\n     * @returns {void}\n     */\n    starttls(callback) {\n        const response = (err, msg) => {\n            if (this.sock == null) {\n                throw new Error('null socket');\n            }\n            if (err) {\n                err.message += ' while establishing a starttls session';\n                caller(callback, err);\n            }\n            else {\n                const secureContext = createSecureContext(typeof this.tls === 'object' ? this.tls : {});\n                const secureSocket = new TLSSocket(this.sock, { secureContext });\n                secureSocket.on('error', (err) => {\n                    this.close(true);\n                    caller(callback, err);\n                });\n                this._secure = true;\n                this.sock = secureSocket;\n                new SMTPResponseMonitor(this.sock, this.timeout, () => this.close(true));\n                caller(callback, msg.data);\n            }\n        };\n        this.command('starttls', response, [220]);\n    }\n    /**\n     * @public\n     * @param {string} data the string to parse for features\n     * @returns {void}\n     */\n    parse_smtp_features(data) {\n        //  According to RFC1869 some (badly written)\n        //  MTA's will disconnect on an ehlo. Toss an exception if\n        //  that happens -ddm\n        data.split('\\n').forEach((ext) => {\n            const parse = ext.match(/^(?:\\d+[-=]?)\\s*?([^\\s]+)(?:\\s+(.*)\\s*?)?$/);\n            // To be able to communicate with as many SMTP servers as possible,\n            // we have to take the old-style auth advertisement into account,\n            // because:\n            // 1) Else our SMTP feature parser gets confused.\n            // 2) There are some servers that only advertise the auth methods we\n            // support using the old style.\n            if (parse != null && this.features != null) {\n                // RFC 1869 requires a space between ehlo keyword and parameters.\n                // It's actually stricter, in that only spaces are allowed between\n                // parameters, but were not going to check for that here.  Note\n                // that the space isn't present if there are no parameters.\n                this.features[parse[1].toLowerCase()] = parse[2] || true;\n            }\n        });\n    }\n    /**\n     * @public\n     * @param {function(...any[]): void} callback function to call after response\n     * @param {string} domain the domain to associate with the 'ehlo' request\n     * @returns {void}\n     */\n    ehlo(callback, domain) {\n        this.features = {};\n        this.command(`ehlo ${domain || this.domain}`, (err, data) => {\n            if (err) {\n                caller(callback, err);\n            }\n            else {\n                this.parse_smtp_features(data);\n                if (this.tls && !this._secure) {\n                    this.starttls(() => this.ehlo(callback, domain));\n                }\n                else {\n                    caller(callback, err, data);\n                }\n            }\n        });\n    }\n    /**\n     * @public\n     * @param {string} opt the features keyname to check\n     * @returns {boolean} whether the extension exists\n     */\n    has_extn(opt) {\n        var _a;\n        return ((_a = this.features) !== null && _a !== void 0 ? _a : {})[opt.toLowerCase()] === undefined;\n    }\n    /**\n     * @public\n     * @description SMTP 'help' command, returns text from the server\n     * @param {function(...any[]): void} callback function to call after response\n     * @param {string} domain the domain to associate with the 'help' request\n     * @returns {void}\n     */\n    help(callback, domain) {\n        this.command(domain ? `help ${domain}` : 'help', callback, [211, 214]);\n    }\n    /**\n     * @public\n     * @param {function(...any[]): void} callback function to call after response\n     * @returns {void}\n     */\n    rset(callback) {\n        this.command('rset', callback);\n    }\n    /**\n     * @public\n     * @param {function(...any[]): void} callback function to call after response\n     * @returns {void}\n     */\n    noop(callback) {\n        this.send('noop', callback);\n    }\n    /**\n     * @public\n     * @param {function(...any[]): void} callback function to call after response\n     * @param {string} from the sender\n     * @returns {void}\n     */\n    mail(callback, from) {\n        this.command(`mail FROM:${from}`, callback);\n    }\n    /**\n     * @public\n     * @param {function(...any[]): void} callback function to call after response\n     * @param {string} to the receiver\n     * @returns {void}\n     */\n    rcpt(callback, to) {\n        this.command(`RCPT TO:${to}`, callback, [250, 251]);\n    }\n    /**\n     * @public\n     * @param {function(...any[]): void} callback function to call after response\n     * @returns {void}\n     */\n    data(callback) {\n        this.command('data', callback, [354]);\n    }\n    /**\n     * @public\n     * @param {function(...any[]): void} callback function to call after response\n     * @returns {void}\n     */\n    data_end(callback) {\n        this.command(`${CRLF}.`, callback);\n    }\n    /**\n     * @public\n     * @param {string} data the message to send\n     * @returns {void}\n     */\n    message(data) {\n        var _a, _b;\n        this.log(data);\n        (_b = (_a = this.sock) === null || _a === void 0 ? void 0 : _a.write(data)) !== null && _b !== void 0 ? _b : this.log('no socket to write to');\n    }\n    /**\n     * @public\n     * @description SMTP 'verify' command -- checks for address validity.\n     * @param {string} address the address to validate\n     * @param {function(...any[]): void} callback function to call after response\n     * @returns {void}\n     */\n    verify(address, callback) {\n        this.command(`vrfy ${address}`, callback, [250, 251, 252]);\n    }\n    /**\n     * @public\n     * @description SMTP 'expn' command -- expands a mailing list.\n     * @param {string} address the mailing list to expand\n     * @param {function(...any[]): void} callback function to call after response\n     * @returns {void}\n     */\n    expn(address, callback) {\n        this.command(`expn ${address}`, callback);\n    }\n    /**\n     * @public\n     * @description Calls this.ehlo() and, if an error occurs, this.helo().\n     *\n     * If there has been no previous EHLO or HELO command self session, self\n     * method tries ESMTP EHLO first.\n     *\n     * @param {function(...any[]): void} callback function to call after response\n     * @param {string} [domain] the domain to associate with the command\n     * @returns {void}\n     */\n    ehlo_or_helo_if_needed(callback, domain) {\n        // is this code callable...?\n        if (!this.features) {\n            const response = (err, data) => caller(callback, err, data);\n            this.ehlo((err, data) => {\n                if (err) {\n                    this.helo(response, domain);\n                }\n                else {\n                    caller(callback, err, data);\n                }\n            }, domain);\n        }\n    }\n    /**\n     * @public\n     *\n     * Log in on an SMTP server that requires authentication.\n     *\n     * If there has been no previous EHLO or HELO command self session, self\n     * method tries ESMTP EHLO first.\n     *\n     * This method will return normally if the authentication was successful.\n     *\n     * @param {function(...any[]): void} callback function to call after response\n     * @param {string} [user] the username to authenticate with\n     * @param {string} [password] the password for the authentication\n     * @param {{ method: string, domain: string }} [options] login options\n     * @returns {void}\n     */\n    login(callback, user, password, options = {}) {\n        var _a, _b;\n        const login = {\n            user: user ? () => user : this.user,\n            password: password ? () => password : this.password,\n            method: (_b = (_a = options === null || options === void 0 ? void 0 : options.method) === null || _a === void 0 ? void 0 : _a.toUpperCase()) !== null && _b !== void 0 ? _b : '',\n        };\n        const domain = (options === null || options === void 0 ? void 0 : options.domain) || this.domain;\n        const initiate = (err, data) => {\n            var _a;\n            if (err) {\n                caller(callback, err);\n                return;\n            }\n            let method = null;\n            /**\n             * @param {string} challenge challenge\n             * @returns {string} base64 cram hash\n             */\n            const encodeCramMd5 = (challenge) => {\n                const hmac = createHmac('md5', login.password());\n                hmac.update(Buffer.from(challenge, 'base64').toString('ascii'));\n                return Buffer.from(`${login.user()} ${hmac.digest('hex')}`).toString('base64');\n            };\n            /**\n             * @returns {string} base64 login/password\n             */\n            const encodePlain = () => Buffer.from(`\\u0000${login.user()}\\u0000${login.password()}`).toString('base64');\n            /**\n             * @see https://developers.google.com/gmail/xoauth2_protocol\n             * @returns {string} base64 xoauth2 auth token\n             */\n            const encodeXoauth2 = () => Buffer.from(`user=${login.user()}\\u0001auth=Bearer ${login.password()}\\u0001\\u0001`).toString('base64');\n            // List of authentication methods we support: from preferred to\n            // less preferred methods.\n            if (!method) {\n                const preferred = this.authentication;\n                let auth = '';\n                if (typeof ((_a = this.features) === null || _a === void 0 ? void 0 : _a['auth']) === 'string') {\n                    auth = this.features['auth'];\n                }\n                for (let i = 0; i < preferred.length; i++) {\n                    if (auth.includes(preferred[i])) {\n                        method = preferred[i];\n                        break;\n                    }\n                }\n            }\n            /**\n             * handle bad responses from command differently\n             * @param {Error} err err\n             * @param {unknown} data data\n             * @returns {void}\n             */\n            const failed = (err, data) => {\n                this.loggedin = false;\n                this.close(); // if auth is bad, close the connection, it won't get better by itself\n                err.message = err.message.replace(this.password(), 'REDACTED');\n                caller(callback, SMTPError.create('authorization.failed', SMTPErrorStates.AUTHFAILED, err, data));\n            };\n            /**\n             * @param {Error} err err\n             * @param {unknown} data data\n             * @returns {void}\n             */\n            const response = (err, data) => {\n                if (err) {\n                    failed(err, data);\n                }\n                else {\n                    this.loggedin = true;\n                    caller(callback, err, data);\n                }\n            };\n            /**\n             * @param {Error} err err\n             * @param {unknown} data data\n             * @param {string} msg msg\n             * @returns {void}\n             */\n            const attempt = (err, data, msg) => {\n                if (err) {\n                    failed(err, data);\n                }\n                else {\n                    if (method === AUTH_METHODS['CRAM-MD5']) {\n                        this.command(encodeCramMd5(msg), response, [235, 503]);\n                    }\n                    else if (method === AUTH_METHODS.LOGIN) {\n                        this.command(Buffer.from(login.password()).toString('base64'), response, [235, 503]);\n                    }\n                }\n            };\n            /**\n             * @param {Error} err err\n             * @param {unknown} data data\n             * @param {string} msg msg\n             * @returns {void}\n             */\n            const attemptUser = (err, data) => {\n                if (err) {\n                    failed(err, data);\n                }\n                else {\n                    if (method === AUTH_METHODS.LOGIN) {\n                        this.command(Buffer.from(login.user()).toString('base64'), attempt, [334]);\n                    }\n                }\n            };\n            switch (method) {\n                case AUTH_METHODS['CRAM-MD5']:\n                    this.command(`AUTH  ${AUTH_METHODS['CRAM-MD5']}`, attempt, [334]);\n                    break;\n                case AUTH_METHODS.LOGIN:\n                    this.command(`AUTH ${AUTH_METHODS.LOGIN}`, attemptUser, [334]);\n                    break;\n                case AUTH_METHODS.PLAIN:\n                    this.command(`AUTH ${AUTH_METHODS.PLAIN} ${encodePlain()}`, response, [235, 503]);\n                    break;\n                case AUTH_METHODS.XOAUTH2:\n                    this.command(`AUTH ${AUTH_METHODS.XOAUTH2} ${encodeXoauth2()}`, response, [235, 503]);\n                    break;\n                default:\n                    caller(callback, SMTPError.create('no form of authorization supported', SMTPErrorStates.AUTHNOTSUPPORTED, null, data));\n                    break;\n            }\n        };\n        this.ehlo_or_helo_if_needed(initiate, domain);\n    }\n    /**\n     * @public\n     * @param {boolean} [force=false] whether or not to force destroy the connection\n     * @returns {void}\n     */\n    close(force = false) {\n        if (this.sock) {\n            if (force) {\n                this.log('smtp connection destroyed!');\n                this.sock.destroy();\n            }\n            else {\n                this.log('smtp connection closed.');\n                this.sock.end();\n            }\n        }\n        if (this.monitor) {\n            this.monitor.stop();\n            this.monitor = null;\n        }\n        this._state = SMTPState.NOTCONNECTED;\n        this._secure = false;\n        this.sock = null;\n        this.features = null;\n        this.loggedin = !(this.user() && this.password());\n    }\n    /**\n     * @public\n     * @param {function(...any[]): void} [callback] function to call after response\n     * @returns {void}\n     */\n    quit(callback) {\n        this.command('quit', (err, data) => {\n            caller(callback, err, data);\n            this.close();\n        }, [221, 250]);\n    }\n}\n\nclass SMTPClient {\n    /**\n     * Create a standard SMTP client backed by a self-managed SMTP connection.\n     *\n     * NOTE: `host` is trimmed before being used to establish a connection; however, the original untrimmed value will still be visible in configuration.\n     *\n     * @param {SMTPConnectionOptions} server smtp options\n     */\n    constructor(server) {\n        this.queue = [];\n        this.sending = false;\n        this.ready = false;\n        this.timer = null;\n        this.smtp = new SMTPConnection(server);\n    }\n    /**\n     * @public\n     * @template {Message | MessageHeaders} T\n     * @param {T} msg the message to send\n     * @param {MessageCallback<T>} callback receiver for the error (if any) as well as the passed-in message / headers\n     * @returns {void}\n     */\n    send(msg, callback) {\n        const message = msg instanceof Message\n            ? msg\n            : this._canMakeMessage(msg)\n                ? new Message(msg)\n                : null;\n        if (message == null) {\n            callback(new Error('message is not a valid Message instance'), msg);\n            return;\n        }\n        const { isValid, validationError } = message.checkValidity();\n        if (isValid) {\n            const stack = this.createMessageStack(message, callback);\n            if (stack.to.length === 0) {\n                return callback(new Error('No recipients found in message'), msg);\n            }\n            this.queue.push(stack);\n            this._poll();\n        }\n        else {\n            callback(new Error(validationError), msg);\n        }\n    }\n    /**\n     * @public\n     * @template {Message | MessageHeaders} T\n     * @param {T} msg the message to send\n     * @returns {Promise<T>} a promise that resolves to the passed-in message / headers\n     */\n    sendAsync(msg) {\n        return new Promise((resolve, reject) => {\n            this.send(msg, (err, message) => {\n                if (err != null) {\n                    reject(err);\n                }\n                else {\n                    // unfortunately, the conditional type doesn't reach here\n                    // fortunately, we only return a `Message` when err is null, so this is safe\n                    resolve(message);\n                }\n            });\n        });\n    }\n    /**\n     * @public\n     * @description Converts a message to the raw object used by the internal stack.\n     * @param {Message} message message to convert\n     * @param {MessageCallback} callback errback\n     * @returns {MessageStack} raw message object\n     */\n    createMessageStack(message, callback = function () {\n        /*  */\n    }) {\n        const [{ address: from }] = addressparser(message.header.from);\n        const stack = {\n            message,\n            to: [],\n            from,\n            callback: callback.bind(this),\n        };\n        const { header: { to, cc, bcc, 'return-path': returnPath }, } = message;\n        if ((typeof to === 'string' || Array.isArray(to)) && to.length > 0) {\n            stack.to = addressparser(to);\n        }\n        if ((typeof cc === 'string' || Array.isArray(cc)) && cc.length > 0) {\n            stack.to = stack.to.concat(addressparser(cc).filter((x) => stack.to.some((y) => y.address === x.address) === false));\n        }\n        if ((typeof bcc === 'string' || Array.isArray(bcc)) && bcc.length > 0) {\n            stack.to = stack.to.concat(addressparser(bcc).filter((x) => stack.to.some((y) => y.address === x.address) === false));\n        }\n        if (typeof returnPath === 'string' && returnPath.length > 0) {\n            const parsedReturnPath = addressparser(returnPath);\n            if (parsedReturnPath.length > 0) {\n                const [{ address: returnPathAddress }] = parsedReturnPath;\n                stack.returnPath = returnPathAddress;\n            }\n        }\n        return stack;\n    }\n    /**\n     * @protected\n     * @returns {void}\n     */\n    _poll() {\n        if (this.timer != null) {\n            clearTimeout(this.timer);\n        }\n        if (this.queue.length) {\n            if (this.smtp.state() == SMTPState.NOTCONNECTED) {\n                this._connect(this.queue[0]);\n            }\n            else if (this.smtp.state() == SMTPState.CONNECTED &&\n                !this.sending &&\n                this.ready) {\n                this._sendmail(this.queue.shift());\n            }\n        }\n        // wait around 1 seconds in case something does come in,\n        // otherwise close out SMTP connection if still open\n        else if (this.smtp.state() == SMTPState.CONNECTED) {\n            this.timer = setTimeout(() => this.smtp.quit(), 1000);\n        }\n    }\n    /**\n     * @protected\n     * @param {MessageStack} stack stack\n     * @returns {void}\n     */\n    _connect(stack) {\n        /**\n         * @param {Error} err callback error\n         * @returns {void}\n         */\n        const connect = (err) => {\n            if (!err) {\n                const begin = (err) => {\n                    if (!err) {\n                        this.ready = true;\n                        this._poll();\n                    }\n                    else {\n                        stack.callback(err, stack.message);\n                        // clear out the queue so all callbacks can be called with the same error message\n                        this.queue.shift();\n                        this._poll();\n                    }\n                };\n                if (!this.smtp.authorized()) {\n                    this.smtp.login(begin);\n                }\n                else {\n                    this.smtp.ehlo_or_helo_if_needed(begin);\n                }\n            }\n            else {\n                stack.callback(err, stack.message);\n                // clear out the queue so all callbacks can be called with the same error message\n                this.queue.shift();\n                this._poll();\n            }\n        };\n        this.ready = false;\n        this.smtp.connect(connect);\n    }\n    /**\n     * @protected\n     * @param {MessageStack} msg message stack\n     * @returns {boolean} can make message\n     */\n    _canMakeMessage(msg) {\n        return (msg.from &&\n            (msg.to || msg.cc || msg.bcc) &&\n            (msg.text !== undefined || this._containsInlinedHtml(msg.attachment)));\n    }\n    /**\n     * @protected\n     * @param {MessageAttachment | MessageAttachment[]} attachment attachment\n     * @returns {boolean} whether the attachment contains inlined html\n     */\n    _containsInlinedHtml(attachment) {\n        if (Array.isArray(attachment)) {\n            return attachment.some((att) => {\n                return this._isAttachmentInlinedHtml(att);\n            });\n        }\n        else {\n            return this._isAttachmentInlinedHtml(attachment);\n        }\n    }\n    /**\n     * @protected\n     * @param {MessageAttachment} attachment attachment\n     * @returns {boolean} whether the attachment is inlined html\n     */\n    _isAttachmentInlinedHtml(attachment) {\n        return (attachment &&\n            (attachment.data || attachment.path) &&\n            attachment.alternative === true);\n    }\n    /**\n     * @protected\n     * @param {MessageStack} stack stack\n     * @param {function(MessageStack): void} next next\n     * @returns {function(Error): void} callback\n     */\n    _sendsmtp(stack, next) {\n        /**\n         * @param {Error} [err] error\n         * @returns {void}\n         */\n        return (err) => {\n            if (!err && next) {\n                next.apply(this, [stack]);\n            }\n            else {\n                // if we snag on SMTP commands, call done, passing the error\n                // but first reset SMTP state so queue can continue polling\n                this.smtp.rset(() => this._senddone(err, stack));\n            }\n        };\n    }\n    /**\n     * @protected\n     * @param {MessageStack} stack stack\n     * @returns {void}\n     */\n    _sendmail(stack) {\n        const from = stack.returnPath || stack.from;\n        this.sending = true;\n        this.smtp.mail(this._sendsmtp(stack, this._sendrcpt), '<' + from + '>');\n    }\n    /**\n     * @protected\n     * @param {MessageStack} stack stack\n     * @returns {void}\n     */\n    _sendrcpt(stack) {\n        var _a;\n        if (stack.to == null || typeof stack.to === 'string') {\n            throw new TypeError('stack.to must be array');\n        }\n        const to = (_a = stack.to.shift()) === null || _a === void 0 ? void 0 : _a.address;\n        this.smtp.rcpt(this._sendsmtp(stack, stack.to.length ? this._sendrcpt : this._senddata), `<${to}>`);\n    }\n    /**\n     * @protected\n     * @param {MessageStack} stack stack\n     * @returns {void}\n     */\n    _senddata(stack) {\n        this.smtp.data(this._sendsmtp(stack, this._sendmessage));\n    }\n    /**\n     * @protected\n     * @param {MessageStack} stack stack\n     * @returns {void}\n     */\n    _sendmessage(stack) {\n        const stream = stack.message.stream();\n        stream.on('data', (data) => this.smtp.message(data));\n        stream.on('end', () => {\n            this.smtp.data_end(this._sendsmtp(stack, () => this._senddone(null, stack)));\n        });\n        // there is no way to cancel a message while in the DATA portion,\n        // so we have to close the socket to prevent a bad email from going out\n        stream.on('error', (err) => {\n            this.smtp.close();\n            this._senddone(err, stack);\n        });\n    }\n    /**\n     * @protected\n     * @param {Error} err err\n     * @param {MessageStack} stack stack\n     * @returns {void}\n     */\n    _senddone(err, stack) {\n        this.sending = false;\n        stack.callback(err, stack.message);\n        this._poll();\n    }\n}\n\nexport { AUTH_METHODS, BUFFERSIZE, DEFAULT_TIMEOUT, MIME64CHUNK, MIMECHUNK, Message, SMTPClient, SMTPConnection, SMTPError, SMTPErrorStates, SMTPResponseMonitor, SMTPState, addressparser, getRFC2822Date, getRFC2822DateUTC, isRFC2822Date, mimeEncode, mimeWordEncode };\n//# sourceMappingURL=email.js.map\n"],
  "mappings": "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",
  "names": ["match", "err", "message", "close", "_a", "data", "connect"]
}
